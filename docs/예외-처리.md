
---

## ❗ 예외 처리 구조

본 프로젝트는 모든 도메인에서 예외를 일관되게 처리하기 위해
**전역 ErrorCode + 커스텀 Exception + 공통 ErrorResponse 구조**를 채택했습니다.

예외 발생 시 다음과 같은 형식으로 응답됩니다:

```json
{
  "message": "존재하지 않는 사용자입니다.",
  "code": "USER_NOT_FOUND",
  "status": 404
}
```

---

### 📌 처리 흐름 요약

1. 각 도메인에서 `BusinessException` 상속받아 예외 던짐
2. `ErrorCode` enum으로 도메인별 메시지/상태 코드 정의
3. `GlobalExceptionHandler`에서 모든 예외 처리 통합
4. `ErrorResponse` 형식으로 프론트에 응답 (Swagger에도 동일 형식 반영)

---

### 🧱 핵심 클래스

#### ✅ `ErrorCode.java`

```java
@Getter
public enum ErrorCode {
    USER_NOT_FOUND("존재하지 않는 사용자입니다.", HttpStatus.NOT_FOUND),
    INVALID_PAYMENT("결제 승인 실패", HttpStatus.BAD_REQUEST),
    COUPON_OUT_OF_STOCK("쿠폰이 모두 소진되었습니다.", HttpStatus.BAD_REQUEST),
    DUPLICATE_EMAIL("이미 가입된 이메일입니다.", HttpStatus.BAD_REQUEST),
    UNKNOWN_ERROR("서버 내부 오류가 발생했습니다.", HttpStatus.INTERNAL_SERVER_ERROR),
    // 생략...
    ;

    private final String message;
    private final HttpStatus status;

    ErrorCode(String message, HttpStatus status) {
        this.message = message;
        this.status = status;
    }
}
```

---

#### ✅ `BusinessException.java`

```java
@Getter
public abstract class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}
```

---

#### ✅ `ErrorResponse.java`

```java
@Getter
@AllArgsConstructor
@Schema(description = "에러 응답 객체 예시")
public class ErrorResponse {

  @Schema(description = "에러 메시지", example = "존재하지 않는 사용자입니다.")
  private final String message;

  @Schema(description = "에러 코드", example = "USER_NOT_FOUND")
  private final String code;

  @Schema(description = "HTTP 상태 코드", example = "404")
  private final int status;
}
```

---

#### ✅ `GlobalExceptionHandler.java`

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        log.warn("Business 예외 발생: {}", ex.getMessage());
        return ResponseEntity
                .status(ex.getErrorCode().getStatus())
                .body(new ErrorResponse(
                        ex.getErrorCode().getMessage(),
                        ex.getErrorCode().name(),
                        ex.getErrorCode().getStatus().value()
                ));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        String errorMessage = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .findFirst()
                .orElse("유효성 검사 실패");

        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse(
                        errorMessage,
                        ErrorCode.INVALID_REQUEST.name(),
                        HttpStatus.BAD_REQUEST.value()
                ));
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<ErrorResponse> handleRuntimeException(RuntimeException ex) {
        log.error("서버 오류 발생", ex);
        return ResponseEntity
                .status(ErrorCode.UNKNOWN_ERROR.getStatus())
                .body(new ErrorResponse(
                        ErrorCode.UNKNOWN_ERROR.getMessage(),
                        ErrorCode.UNKNOWN_ERROR.name(),
                        ErrorCode.UNKNOWN_ERROR.getStatus().value()
                ));
    }
}
```

---

#### ✅ 예시 커스텀 예외 클래스

```java
public class DuplicateEmailException extends BusinessException {
    public DuplicateEmailException() {
        super(ErrorCode.DUPLICATE_EMAIL);
    }
}

public class MissingUserIdForMeEndpointException extends BusinessException {
    public MissingUserIdForMeEndpointException() {
        super(ErrorCode.MISSING_USER_ID_FOR_ME_ENDPOINT);
    }
}
```

---
